# Singleton单例模式

## 什么是单例？

  单例是一种设计模式，顾名思义即全局只有一个实例，其需要提供一个访问的接口供其他模块调用。其实说得再简单点，单例的实例其实就是一个特殊的全局变量。

  单例模式作为一种基础设计模式，相信很多同学都用过，因为写起来很爽，可以在任何的地方直接获取到目标实例做一些操作，在一定程度上提高了开发效率。但如果使用不得当，也很容易带来一些风险，让项目变得混乱起来。接下来列举下单例的优缺点。

## 优点

### 1、全局唯一，且可以全局访问

  在游戏的一个完整生命周期内，只存在一个实例，不会被重复创建。一些单例类保存有某些数据，而错误的使用则可能会创建出多个实例，并分别存有某些数据，导致出现不知名的Bug。单例使用一个简单的写法可以保证不会出现重复创建的问题(多线程的话就得慎重了！！)。

  在面向对象编程中，很多时候新手程序员都会很苦恼，这个对象实例要从哪里拿到，才能去调用对应的方法。而引入单例可以降低他们的学习难度，在一定程度上提高了开发效率。

### 2、使用的时候才初始化

  如果一个单例在游戏过程中一直没有被使用，那它就不会被创建，比如我们写了一个聊天系统的存储单例，而玩家进游戏一直没有进过聊天系统，那就不会去创建这个存储的单例，也就不会去读取大量的聊天数据，这在一定程度上减轻了内存和CPU的压力。

### 3、运行时初始化

  单例可以在运行的时候初始化，这意味着这个类可以访问到一些额外的数据，并且可以自行控制初始化顺序，自己能把控的东西才会安心。

  单例通常可以使用一个静态类来代替，但是后者在编译的时候做初始化，很多数据是拿不到的；而且因为静态类的编译顺序是依赖于编译器的，所以如果类与类有依赖关系就很容易出问题。(当然一般也不推荐让这种类在初始化的时候互相依赖)。

### 4、可以继承

  这一点其实目前我用到的不多，不过《游戏编程模式》有提到，这里也放上来。如UE的Subsystem?

## 缺点

### 1、可以被全局访问

  但凡是个程序员，多多少少应该都被告知过，少用全局变量吧。全局变量会让项目变得很混乱，一个数值的改变可能有几百几千个修改的地方，在出现问题的时候简直是噩梦。并且也会加强代码的耦合性。一个类的字段被其他很多个类引用着。

### 2、在存在多线程的地方有很大风险

  通常单例我们会在全局访问的入口处判断这个单例是否已经被实例化，如果没有被实例化才会实例化出来并返回，否则直接返回。而如果是多线程访问时，很可能在同一时间被两个地方同时访问，并且同时判断成功，并实例化出两个类。

### 3、延迟实例化导致卡顿

  这里还是用之前聊天存储单例的例子，因为在调用的时候才做的实例化，而调用的时候可能是在战斗的时候才打开聊天频道呼叫支援，这可能会导致你的战斗卡顿。(这种情况一般是特殊处理，如果一个单例实例化代价可能会比较大，则将这个实例化的时间提前，比如在加载的界面或者是通过其他方式提前手动实例化，避免关键时刻掉链子)

### 使用情境

  “类名.Instance.成员名"访问

  尽管在《游戏编程模式》中关于单例模式那一章里，作者费了很多笔墨来告诉我们不要使用单例，但实在架不住好用啊。单例在游戏开发过程中虽然不是必不可少的，但是基本都会用到。不过我们既然知道了这些缺点，那使用的时候就要小心，别一头栽到里面了。

  我们要实现的是一套Manage of Managers的框架，即用不同的Manager来管理不同的系统，而这些Manager大部分都是一个单例。我们也将引入一些其他的东西来尽可能减少耦合性，比如后一节的事件模块。如果耦合无可避免，那就把耦合的地方都集中到一个类里吧。


### 实现方式

  步骤：

  1. 构造函数私有化防止外部创建对象

  2. 提供一个属性给外部访问
   
### 分类

  1. 饿汉式：在程序一开始的时候就创建了单例对象。但这样一来就会占据内存。（没有多线程的问题）
  2. 懒汉式：用到单例才创建。（这种方式要考虑线程安全）
